---
id: Files
created_date: 2025-10-17
updated_date: 2025-10-17
type: note
link: "[[io Reader, io Writer]]"
tags:
  - 10-2025
  - IT
  - go
---

# Files

## Открытие файла
`Чтение и запись файлов` — базовые операции для многих приложений.

Допустим, у нас есть файл `literature.txt` со списком литературы на лето. Давайте прочитаем его:

```go
data, err := os.ReadFile("literature.txt")
```

Мы можем просто открыть файл, но не читать его:

```go
f, err := os.Open("movie.mkv")
```

В таком случае в объекте `f` будет не содержимое файла, а его дескриптор, с помощью которого мы прочтём сам файл:

```go
buffer := make([]byte, 100) // Будем считывать файл в этот слайс
_, err := f.Read(buffer) // Читаем часть файла   
```

`buffer` — это объект, в который мы будем читать файл. После чтения в нём находится 100 байтов нашего файла — либо ещё меньше, если сам файл небольшой.

Как же нам прочитать весь файл с фильмом?  
Мы будем делать это последовательно:

```go

buffer := make([]byte, 100)
for {
  // n — число байтов, которые удалось прочитать
  n, err := f.Read(buffer) // Прочитаем часть в buffer
  if err == io.EOF {   // Ошибка показывает, что файл прочитан полностью
    break // Выходим из цикла, файл прочитан
  }
  if err != nil { // Эту ошибку нужно обработать
    // Ошибка чтения
  }
  process(buffer[:n]) // Функция для дальнейшей обработки
} 
```

Было бы гораздо удобнее считывать файл построчно. Вот как это сделать:

```go
f, err := os.Open("movie.mkv")
fileScanner := bufio.NewScanner(f)
for fileScanner.Scan() {
  process(fileScanner.Text())
}
```

Самый простой способ — прочесть файл от начала до конца, но оптимальнее будет применить функцию `Seek`. С её помощью можно читать файл не с начала, а с выбранного места:

![](https://yastatic.net/s3/lyceum/files/350f2f42-4838-46a0-826c-2e558eb68440/upload.png)

Как можно её использовать:

```go
offset := 1024
f.Seek(offset, 0) // Сместимся от начала файла
buffer := make([]byte, 100)
n, err := f.Read(buffer) // Прочитаем в buffer с позиции 1024 
```


## Закрытие файла
Отсюда золотое правило использования любых конечных ресурсов (не только файловых дескрипторов, но и, например, подключений к базе данных): взять, использовать, вернуть на место.

```go
err := f.Close()
```

Чтобы не забыть это сделать, рекомендуем использовать конструкцию `defer`. Это позволит поместить код закрытия рядом с открытием:

```go

file, err := os.Open("movie.mkv") // Откроем файл
defer f.Close() // Закроем файл
// Здесь файл будет читаться
    
```

## Запись в файл

Если у вас есть слайс с данными, записать его можно с помощью функции `os.WriteFile`:

![](https://yastatic.net/s3/lyceum/files/d5bc501a-4f42-4898-91f4-48eecc55eeb3/upload.png)

А что случится, если файла, в который мы хотим записать данные, нет?  
`os.Writefile` создаст его с указанными разрешениями. Если файл уже есть, функция перезапишет его содержимое, тоже не меняя разрешения.

Мы можем получить дескриптор самого файла так же, как дескриптор на его чтение:

```go

f, err := os.Create("C:\Users\Docs\myfile.txt")
defer func() {
  errClose := f.Close() // Не забываем закрыть и проверить на ошибку — при записи файла это важно
}()
```

Если файл существует, он будет перезаписан, а если не существует — создан. Теперь мы можем записать данные с помощью дескриптора:

```go
n, err := f.WriteString("hello") // n — сколько байтов записали
```

А если нам нужно дописать данные в уже существующий файл? Функция `os.Create` заменит его на пустой. Чтобы этого не случилось, воспользуемся `os.OpenFile`:

```go

f, err := os.OpenFile(filename, os.O_APPEND | os.O_WRONLY, 0600)
    
```

Число 0600 предоставляет [права доступа](https://en.wikipedia.org/wiki/File-system_permissions) к файловой системе. У этих битов — одинаковое определение во всех системах, так что информация о файлах может быть перенесена из одной ОС в другую.