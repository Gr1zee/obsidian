---
id: Gorutines
created_date: 2025-10-18
updated_date: 2025-10-18
type: note
link:
tags:
  - 10-2025
  - IT
  - go
---

# Gorutines

## Планировщик в Go

![[upload.png]]

`Планировщик Go` отвечает за управление горутинами. Он решает, на каком ядре, когда и какая из них должна быть запущена.

В планировщике Go есть две важные структуры данных для управления горутинами — LRQ (Local Run Queue) и GRQ (Global Run Queue).

`LRQ` — это очередь выполнения для конкретного процессора (P). У каждого P есть своя собственная очередь с горутинами, готовыми к выполнению на этом процессоре.

`GRQ` — это общая очередь выполнения с горутинами, готовыми к выполнению, но не назначенными конкретному процессору (P). Когда P ищет горутину для выполнения и его LRQ пуст, он может взять её из GRQ.

А вот ещё несколько характеристик горутин:

- `Горутина` — это структура, которая выполняет переданную функцию
- Самый объёмный элемент структуры — `stack`. По умолчанию выделяется 2 Кб
- В процессе выполнения стек может увеличиваться, если потребуется
- У стека есть максимальный размер: 1 Гб для 64 бит, 250 Мб для 32 бит

## Каналы

Чтобы безопасно передавать информацию между горутинами, есть специальный тип данных — `канал`. Вот как его можно создать и использовать:

```go

package main

import (
  "fmt"
)

func main() {
  ch := make(chan int)

  go func() {
    ch <- 123 // отправляем значение в канал
  }()

  val := <-ch // получаем значение из канала
  fmt.Println(val) // выводит 123
}
    
```

## Буферизованные и небуферизованные каналы

Каналы в Go могут быть буферизированными и не буферизированными.

У `небуферизованных` каналов нет внутреннего буфера, поэтому необходимо, чтобы обе горутины были готовы к обмену.
Если горутина пытается отправить данные в небуферизованный канал, а горутины, которая ожидала бы получить эти данные, нет, канал заблокирует отправляющую горутину и заставит её ждать
![[upload 1.png]]

У `буферизованных` каналов есть внутренний буфер, поэтому они могут вести себя немного по-другому. Когда горутина пытается отправить данные в буферизованный канал, но он заполнен, канал блокирует горутину и заставляет ждать, пока буфер не станет доступным.
![[upload 2.png]]
## Дедлок
`Дедлок` — состояние, при котором группа горутин вечно ожидают друг друга, так как никто не может продолжить выполнять свой код. Обычно это происходит, когда горутина ожидает получить данные из канала, но никакая другая горутина их туда не отправляет. В таких случаях Go завершает выполнение программы и выводит сообщение о дедлоке.

Пример дедлока с помощью канала:

```go
package main

func main() {
  ch := make(chan int)
  ch <- 1 // это приведёт к дедлоку, так как нет другой горутины, которая могла бы принять значение
} 
```

