---
id: Mutex
created_date: 2025-10-19
updated_date: 2025-10-19
type: note
link:
tags:
  - 10-2025
  - go
  - IT
---

# Mutex

Он помогает создать критическую секцию (подробнее о ней можно почитать [здесь](https://ru.wikipedia.org/wiki/Критическая_секция)), которая гарантирует, что только одна горутина сможет выполнять выбранный раздел кода.

## Кэширование данных

Программистам часто бывает нужно реализовать кэширование. Некоторые операции (например, дорогостоящие вычисления, операции ввода-вывода или работа с базами данных) выполняются медленно, поэтому кэшировать результаты имеет смысл после того, как они будут получены.

Давайте попробуем написать кэш, который загружает объекты из базы данных и помещает их в мапу.

Для этого создадим интерфейс, который описывает метод получения данных из базы:

```go
type DataRetriever interface {
  Retrieve(ID string) (*Data, error)
}
```

Любая база данных либо другие источники, которые реализуют интерфейс `DataRetriever`, могут быть использованы в нашем кэше.

Далее создадим структуру для описания данных:

```go

type Data struct {
  ID string // для упрощения содержит только ID
}
    
```

Теперь запрограммируем сам кэш:

```go
// кэш для хранения данных
type Cache struct {
  // данные будем хранить здесь
  m  map[string]*Data
  dr DataRetriever
}
// создаём новый объект
func NewCache(dr DataRetriever) *Cache {
  return &Cache{
    m:  make(map[string]*Data),
    dr: dr,
  }
}
```

Реализуем метод `Get`, чтобы получать данные из кэша:
```go
func (c *Cache) Get(ID string) (Data, bool) {
  // проверим, есть ли данные в кэше
  data, exists := c.m[ID]
  // нашли в мапе — вернём значение
  if exists {
    return *data, true
  }
  // данные не нашли — нужно запросить
  data, err := c.dr.Retrieve(ID)
  if err != nil {
    // ошибка получения данных — запишем в лог
    log.Printf("c.dr.Retrieve(ID): %s", err)
    // вернём пустое значение
    return Data{}, false
  }
  // получили значение — запомним
  c.m[data.ID] = data
  // вернём полученное значение
  return *data, true
}
```
Это вполне рабочий вариант, но только если мы используем его в одной горутине. При чтении кэша и записи в него несколькими горутинами мы получим состояние гонки (race condition).

В `состоянии гонки` (race condition) несколько потоков (или процессов) одновременно пытаются выполнить операции чтения и записи.

Кэш обычно используется многими горутинами, поэтому он должен быть потокобезопасным. Для этого добавим мьютекс:

```go

type Cache struct {
   m  map[string]*Data
   dr DataRetriever
   mu sync.Mutex
}
```

Вызов `mu.Lock()` и `mu.Unlock()` будет определять, что находится в критической секции. Только после вызова `Unlock()` другая горутина сможет заблокировать мьютекс `mu` с помощью `mu.Lock()`. Внесём изменения в функцию `Get`:

```go

func (c *Cache) Get(ID string) (Data, bool) {
   c.mu.Lock()
   data, exists := c.m[ID] // теперь доступ к мапе внутри критической секции
   c.mu.Unlock()
   // нашли в мапе — вернём значение
   if exists {
    return *data, true
   }
   // запрос данных из базы — не в критической секции
   data, err := c.dr.Retrieve(ID) 
   if err != nil {
    // ошибка получения данных — запишем в лог
    log.Printf("c.dr.Retrieve(ID): %s", err)
    // вернём пустое значение
    return Data{}, false
   } 
   // перед обращением к мапе снова заблокируем мьютекс
   c.mu.Lock()
   // разблокируем при выходе из функциии
   defer c.mu.Unlock()
   // внутри критической секции нужно снова проверить на наличие значения в мапе
   data, exists = c.m[data.ID]
   if exists {
    return *data, true
   }
   // получили значение — запомним
   c.m[data.ID] = data
   // вернём полученное значение
   return *data, true
}
```


## RWMutex

В некоторых случаях, как в примере с кэшем, можно выделить два типа критических секций, для чтения и для записи. Мы можем предположить, что чтение объекта из мапы несколькими горутинами не нарушит её целостность, поэтому хорошо бы блокировать чтение только в момент записи другими горутинами. Для этого можно использовать `RWMutex`:

```go

type Cache struct {
  m  map[string]*Data
  dr DataRetriever
  mu sync.RWMutex
}
    
```

Давайте посмотрим, как изменится код `Get`:

```go

 func (c *Cache) Get(ID string) (Data, bool) {
  c.mu.RLock()
  // теперь в эту секцию могут зайти несколько горутин
  data, exists := c.m[ID] 
  c.mu.RUnlock()
  // далее без изменений
}
    
```

## Двойная блокировка

Мьютекс не отслеживает, какая горутина его заблокировала, поэтому двойная блокировка мьютекса из одной и той же горутины приведёт к её собственной блокировке. Это распространённая проблема с несколькими функциями, которые могут вызывать друг друга, а также блокировать один и тот же мьютекс:

```go

var m sync.Mutex

func first() {
  m.Lock()
  defer m.Unlock()
  second() // lock
}

func second() {
  m.Lock() // здесь будет вызов m.Lock() второй раз
  defer m.Unlock()
  // далее — основное тело функции 
}
    
```