---
id: Context
created_date: 2025-10-19
updated_date: 2025-10-19
type: note
link:
tags:
  - 10-2025
  - IT
  - go
---

# Context for concurrency

Пакет `context` — важнейший инструмент для управления временем выполнения операций и передачи данных между процессами. Он помогает контролировать тайм-ауты, отменять долгие запросы и синхронизировать работу горутин.

## **Основные типы Context в Go**

Go предоставляет четыре ключевые функции для создания контекста:

- `context.Background()` — создаёт пустой контекст, обычно используется как корневой.
- `context.TODO()` — применяется, когда контекст пока неизвестен или в процессе разработки.
- `context.WithCancel()` — создаёт контекст, который можно отменить вручную.
- `context.WithTimeout()` — создаёт контекст с автоматической отменой по тайм-ауту.
- `context.WithDeadline()` — создаёт контекст с автоматической отменой в заданное время.
- `context.WithValue()` — создаёт контекст с дополнительными данными.

`WithCancel` создаёт контекст, который можно отменить вручную. Этот механизм удобен, когда нужно прервать работу горутин при наступлении определённого события.
## Передача значения в контексте

При обработке запросов (например, на сервере) обычно требуется передавать какие-либо данные, специфичные для этого запроса, ниже по стеку. Например:

```go

func ProcessRequest(userID string) {
  // сохраним значение в контексте
  ctx := context.WithValue(context.Background(), "userID", userID)
  // функция обработки
  HandleResponse(ctx)
}
// здесь контекст уже содержит userID
func HandleResponse(ctx context.Context) {
  fmt.Printf("handling response for (%v)", ctx.Value("userID"))
}
    
```

Важно отметить, что значения, которые хранятся в определённом контексте, изменить нельзя (immutable). Когда мы вызываем `context.WithValue`, мы передаём родительский контекст и получаем контекст обратно, поскольку эта функция его не изменила. Вместо этого она завернула родительский контекст в другой с новым значением.  
`Рассмотрим пример`:

```go

// сохраним значение myValue по ключу myKey
ctx = context.WithValue(ctx, "myKey", "myValue")
fmt.Printf("my value is %s\n", ctx.Value("myKey")) // my value is myValue
// сохраним значение anotherValue по ключу myKey
anotherCtx := context.WithValue(ctx, "myKey", "anotherValue")
fmt.Printf("my value is %s\n", ctx.Value("myKey")) // my value is anotherValue
    
```

Когда мы используем метод `Value`, он находит самое «внешнее» значение (из последнего контекста) для этого ключа и возвращает значение.

В простых программах допускается сохранять значения стандартных типов в контексте, однако это может привести к `коллизиям`.  
Давайте взглянем на такой код:

```go

func HandleResponse(ctx context.Context) { // допустим, переданный контекст содержит значение по ключу userID
  newUserID := "22"
  ctx = context.WithValue(ctx, "userID", newUserID) // запишем значение по ключу userID
  fmt.Printf("handling response for (%v)", ctx.Value"userID")) // handling response for 22
}    
```

В рамках одного пакета такой ошибки можно избежать.  
А что если вы используете пакеты сторонних разработчиков? Чтобы предотвратить подобные ситуации в реальных системах, рекомендуем создавать отдельный тип данных для сохранения в контексте:

```go

// создадим тип данных для хранения id пользоваталя
type userID string
func ProcessRequest(id userID) {
  // сохраним значение в контексте
  ctx := context.WithValue(context.Background(), "userID", id)
}
    
```

Когда значение будет получено, достаточно будет проверить тип сохранённого объекта, чтобы убедиться, что он сохранён в рамках вашего пакета:

```go

id, ok := ctx.Value("userID").(userID)
if !ok{
  // другой тип объекта
}
    
```

Когда вы сохраняете значение в контекст, всегда помните, что оно может быть использовано в различных горутинах.

# Когда использовать context.WithValue

Конечно, заманчиво поместить все ваши данные в контекст и использовать их в функциях вместо параметров, но такой код будет трудновато читать и поддерживать.

Обычно любые данные, необходимые для запуска функции, нужно передавать в качестве параметров.  
Иногда может быть полезно сохранять некоторые значения (например, имена пользователей), в значениях контекста. Но если имя пользователя используется для того, чтобы повлиять на результат работы функции (например, в конструкции `if`), вам следует включить имя в качестве её параметра, даже если оно уже доступно из контекста.

Когда программы используют `context` и передают его от функции к функции, они также передают информацию от `main` до самого глубокого вызова в программе. Например, контекст при обработке http-запроса позволяет получить информацию о клиенте, который делает запрос, и завершить обработку, если клиент отключится до завершения запроса. Также с помощью `http.TimeoutHandler` можно ограничить время обработки запроса сервером (документация по теме [здесь](https://pkg.go.dev/net/http#TimeoutHandler)).

<mark style="background: #FFF3A3A6;">Таким образом, если вы задумываетесь, использовать ли контекст или изобрести что-то другое для, например, отмены выполнения программы, лучше используйте контекст, это правило хорошего программистского тона.</mark>